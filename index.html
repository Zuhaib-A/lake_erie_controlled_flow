
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Engineering_Solution</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-05-09"><meta name="DC.source" content="Engineering_Solution.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%Proposed engineering solution as part of a project in a mathematics module</span>
<span class="comment">%at university to prevent the volume of Lake Erie from decreasing.</span>

<span class="comment">%Importing the data from the excel file called "Raw.xlsx"</span>
dates_table=readtable(<span class="string">"Raw.xlsx"</span>,<span class="string">"Sheet"</span>,<span class="string">"Lake Erie"</span>,<span class="string">"Range"</span>,<span class="string">"A2:A841"</span>);
<span class="comment">%Converting the table of data to a usable array and assigning the variables</span>
<span class="comment">%Known area and 2019 volume of Lakes Erie and Ontario</span>
erie_vol_2019=480*1000^3;
ontar_vol_2019=1700*1000^3;
erie_area=25700*1000^2;
ontar_area=19000*1000^2;
dates=table2array(dates_table);
r3=(xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Erie"</span>, <span class="string">"B2:B841"</span>)*erie_area)/1000;
p3=(xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Erie"</span>, <span class="string">"C2:C841"</span>)*erie_area)/1000;
e3=(xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Erie"</span>, <span class="string">"D2:D841"</span>)*erie_area)/1000;
d3=xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Erie"</span>, <span class="string">"E2:E841"</span>)*60*60*24*30;
fo2=xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Erie"</span>, <span class="string">"F2:F841"</span>)*60*60*24*30;
fo3=xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Erie"</span>, <span class="string">"G2:G841"</span>)*60*60*24*30;
r4=(xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Ontario"</span>, <span class="string">"B2:B841"</span>)*ontar_area)/1000;
p4=(xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Ontario"</span>, <span class="string">"C2:C841"</span>)*ontar_area)/1000;
e4=(xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Ontario"</span>, <span class="string">"D2:D841"</span>)*ontar_area)/1000;
d3=xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Ontario"</span>, <span class="string">"E2:E841"</span>)*60*60*24*30;
fo4=xlsread(<span class="string">"Raw"</span>,<span class="string">"Lake Ontario"</span>, <span class="string">"G2:G841"</span>)*60*60*24*30;
<span class="comment">%Creating inflow, outflow and dv/dt arrays to find the changing water balance.</span>
<span class="comment">%Water balances include real and controlled balances.</span>
erie_inflow=r3+p3+fo2;
erie_non_liquid_outflow=e3;
<span class="comment">%Water flow from Lake Erie to Ontario is isolated so it can be controlled</span>
<span class="comment">%in the dam system.</span>
erie_to_ontar_flow=fo3+d3;
erie_total_outflow=erie_non_liquid_outflow+erie_to_ontar_flow;
erie_original_dvdt=erie_inflow-erie_total_outflow;
ontar_normal_inflow=p4+r4;
ontar_outflow=e4+fo4;
ontar_dvdt=ontar_normal_inflow+erie_to_ontar_flow-ontar_outflow;
<span class="comment">%Calculating the original 1950 volume of Lakes Erie and Ontario by working backwards</span>
<span class="comment">%with the given data</span>
<span class="comment">%Lake Erie initial volume</span>
backwards_erie_vol=[];
backwards_erie_vol(840)=erie_vol_2019-erie_original_dvdt(840);
<span class="keyword">for</span> i = (length(erie_original_dvdt))-1:-1:1
    backwards_erie_vol(i)=[backwards_erie_vol(i+1)-erie_original_dvdt(i+1)];
<span class="keyword">end</span>
initial_erie_vol=backwards_erie_vol(1);
<span class="comment">%Lake Ontario initial volume</span>
backwards_ontar_vol=[];
backwards_ontar_vol(840)=ontar_vol_2019-ontar_dvdt(840);
<span class="keyword">for</span> i = (length(ontar_dvdt))-1:-1:1
    backwards_ontar_vol(i)=[backwards_ontar_vol(i+1)-ontar_dvdt(i+1)];
<span class="keyword">end</span>
initial_ontar_vol=backwards_ontar_vol(1);
<span class="comment">%The water balance model begins with the creation of the volume and balance arrays</span>
erie_dvdt=[]';
ontar_vol=[];
erie_vol=[];
<span class="comment">%Setting the initial values as this makes the outflows easier to control</span>
<span class="comment">%when compared to using cumtrapz.</span>
erie_dvdt(1)=erie_inflow(1)-erie_total_outflow(1);
ontar_vol(1)=initial_ontar_vol+erie_to_ontar_flow(1)-ontar_outflow(1);
erie_vol(1)=initial_erie_vol+erie_dvdt(1);
<span class="comment">%The model will simulate the system under different conditions thousands</span>
<span class="comment">%of times: percentage of allowed inflow into Lake Ontario from Erie and the</span>
<span class="comment">%optimal average surface height of Lake Erie to stablise the volume of Lake Erie.</span>
lowest_percentages=[];
lowest_heights=[];
lowest_means=[];
final_ontar_vol=[];
<span class="comment">%A minimum percentage of 90% is chosen as too low will mean a huge amount</span>
<span class="comment">%of water flow is restricted which can be dangerous so 90% is considered as</span>
<span class="comment">%a safe minimum.</span>
percentages=[0.90:0.01:1];
<span class="keyword">for</span> x=percentages
<span class="comment">%The ideal surface height of Lake Erie will be somewhere between the</span>
<span class="comment">%initial height in 1950 and 2019.</span>
ideal_erie_height=[floor(erie_vol_2019/erie_area):0.01:ceil(initial_erie_vol/erie_area)];
<span class="keyword">for</span> n=ideal_erie_height
<span class="comment">%Thousands of simulations are running and each time temporary arrays are</span>
<span class="comment">%created to store the required values of the dv/dt means and lake volumes</span>
<span class="comment">%for example.</span>
means_temp=[];
erie_height=[];
erie_height(1)=erie_vol(1)/erie_area;
<span class="keyword">for</span> i = 2:840
    <span class="comment">% If the previous months surface height of Lake Erie is less than the</span>
    <span class="comment">% optimal height then the flow out to Lake Ontario will be restricted</span>
    <span class="comment">% to prevent the volume from decreasing too much.</span>
    <span class="keyword">if</span> erie_height(i-1)&lt;n;
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i)*x)-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
    <span class="comment">%If the height is greater than or equal to then the flow is not restricted</span>
    <span class="keyword">else</span>
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i))-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
    <span class="keyword">end</span>
    erie_height=[erie_height,(erie_vol(i)/erie_area)];
<span class="keyword">end</span>
    <span class="comment">%Here the array element id at which the lowest dv/dt for the last 25 years</span>
    <span class="comment">%(2004-2019) is found and used to find the optimal conditions.</span>
    final_ontar_vol=[final_ontar_vol,ontar_vol(840)];
    means_temp=[means_temp,mean(erie_dvdt(540:840))];
    lowest_heights=[lowest_heights, n];
    lowest_percentages=[lowest_percentages, x];
    lowest_means=[lowest_means,min(abs(means_temp))];
<span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%The optimal conditions will now need to be filtered and only those</span>
<span class="comment">%simulations that resulted in a volume that is greater than the</span>
<span class="comment">%initial volume under normal conditions to ensure it does not decrease.</span>
accepted_ontar_final_vol=(initial_ontar_vol);
accepted_heights=[];
accepted_percentages=[];
accepted_lowest_dvdt=[];
accepted_volumes=[];
<span class="keyword">for</span> i = 1:length(final_ontar_vol)
    <span class="keyword">if</span> final_ontar_vol(i)&gt;(accepted_ontar_final_vol);
        accepted_heights=[accepted_heights, lowest_heights(i)];
        accepted_percentages=[accepted_percentages, lowest_percentages(i)];
        accepted_lowest_dvdt=[accepted_lowest_dvdt, lowest_means(i)];
        accepted_volumes=[accepted_volumes, final_ontar_vol(i)];
    <span class="keyword">end</span>
<span class="keyword">end</span>
<span class="comment">%After filtering, there may be multiple optimal conditions so the</span>
<span class="comment">%conditions that result in the lowest flow alteration are chosen which will</span>
<span class="comment">%be towards the end of the array hence the 'end' argument.</span>
lowest_id=find(accepted_lowest_dvdt==min(accepted_lowest_dvdt));
<span class="keyword">if</span> length(lowest_id)&gt;1;
    lowest_id=[lowest_id(end)];
<span class="keyword">end</span>

<span class="comment">%Running the model using the optimum conditions this time</span>
erie_dvdt=[];
ontar_vol=[];
erie_vol=[];
ontar_vol(1)=initial_ontar_vol+erie_to_ontar_flow(1)-ontar_outflow(1);
erie_vol(1)=initial_erie_vol+erie_inflow(1)-erie_total_outflow(1);
erie_height=[];
erie_height(1)=erie_vol(1)/erie_area;
x=accepted_percentages(lowest_id);
<span class="keyword">for</span> i = 2:840
    ontar_height(i-1)=ontar_vol(i-1)/ontar_area;
    <span class="keyword">if</span> erie_height(i-1)&lt;accepted_heights(lowest_id);
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i)*x)-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
    <span class="keyword">else</span>
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i))-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
    <span class="keyword">end</span>
     erie_height=[erie_height,(erie_vol(i)/erie_area)];
<span class="keyword">end</span>

<span class="comment">%The final optimal conditions are selected and displayed</span>
disp(<span class="string">"Below are the final optimum conditions and results of the simulation when they are used:"</span>)
disp(<span class="string">"Lowest acceptable average surface height of Lake Erie: "</span> + accepted_heights(lowest_id) + <span class="string">"m"</span>)
disp(<span class="string">"Percentage of outflow that is allowed during restricted months: "</span> + accepted_percentages(lowest_id)*100 + <span class="string">"%"</span>)
disp(<span class="string">"Change in the volume of Lake Erie over past 25 years: "</span>+ mean(erie_dvdt(540:840)) + <span class="string">"m3/month"</span>)
disp(<span class="string">"Final volume of Lake Ontario under these conditions: "</span> + accepted_volumes(lowest_id) + <span class="string">"m3"</span>)

<span class="comment">%Plots which show lake volumes under the effect of the solution and</span>
<span class="comment">%optimal conditions:</span>
figure()
plot(dates,erie_vol)
title(<span class="string">"Volume of Lake Erie (controlled) 1950-2019 (m^3)"</span>)
xlabel(<span class="string">"Time (Month)"</span>)
ylabel(<span class="string">"Volume (m^3)"</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>
pbaspect([5 2 1])
figure()
plot(dates,ontar_vol)
title(<span class="string">"Volume of Lake Ontario (controlled) 1950-2019 (m^3)"</span>)
xlabel(<span class="string">"Time (Month)"</span>)
ylabel(<span class="string">"Volume (m^3)"</span>)
grid <span class="string">on</span>
grid <span class="string">minor</span>
pbaspect([5 2 1])

<span class="comment">%Below the cumtrapz function is used to show what the volumes of the lakes</span>
<span class="comment">%really looked like during the period, 1950-2019 to allow for a comparison.</span>
<span class="comment">%Lake Erie Natural Volume:</span>
erie_natural_inflow=r3+p3+fo2;
erie_natural_outflow=e3+fo3+d3;
erie_natural_dvdt=erie_natural_inflow-erie_natural_outflow;
erie_natural_vol=initial_erie_vol+datenum(cumtrapz(1,erie_natural_dvdt));
figure()
plot(dates,erie_natural_vol)
grid <span class="string">on</span>
grid <span class="string">minor</span>
title(<span class="string">"Volume of Lake Erie (natural) 1950-2019 (m^3)"</span>)
xlabel(<span class="string">"Time (month)"</span>)
ylabel(<span class="string">"Volume (m^3)"</span>)
pbaspect([5 2 1])

<span class="comment">%Lake Ontario Natural Volume:</span>
ontar_natural_inflow=r4+p4+fo3+d3;
ontar_natural_outflow=e4+fo4;
ontar_natural_dvdt=ontar_natural_inflow-ontar_natural_outflow;
ontar_natural_vol=initial_ontar_vol+datenum(cumtrapz(1,ontar_natural_dvdt));
figure()
plot(dates,ontar_natural_vol)
grid <span class="string">on</span>
grid <span class="string">minor</span>
title(<span class="string">"Volume of Lake Ontario (natural) 1950-2019 (m^3)"</span>)
xlabel(<span class="string">"Time (month)"</span>)
ylabel(<span class="string">"Volume (m^3)"</span>)
pbaspect([5 2 1])
</pre><pre class="codeoutput">Below are the final optimum conditions and results of the simulation when they are used:
Lowest acceptable average surface height of Lake Erie: 24.73m
Percentage of outflow that is allowed during restricted months: 90%
Change in the volume of Lake Erie over past 25 years: 40025.3023m3/month
Final volume of Lake Ontario under these conditions: 1551039898864m3
</pre><img vspace="5" hspace="5" src="Engineering_Solution_01.png" alt=""> <img vspace="5" hspace="5" src="Engineering_Solution_02.png" alt=""> <img vspace="5" hspace="5" src="Engineering_Solution_03.png" alt=""> <img vspace="5" hspace="5" src="Engineering_Solution_04.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%Proposed engineering solution as part of a project in a mathematics module 
%at university to prevent the volume of Lake Erie from decreasing.

%Importing the data from the excel file called "Raw.xlsx"
dates_table=readtable("Raw.xlsx","Sheet","Lake Erie","Range","A2:A841");
%Converting the table of data to a usable array and assigning the variables
%Known area and 2019 volume of Lakes Erie and Ontario
erie_vol_2019=480*1000^3;
ontar_vol_2019=1700*1000^3;
erie_area=25700*1000^2;
ontar_area=19000*1000^2;
dates=table2array(dates_table);
r3=(xlsread("Raw","Lake Erie", "B2:B841")*erie_area)/1000;
p3=(xlsread("Raw","Lake Erie", "C2:C841")*erie_area)/1000;
e3=(xlsread("Raw","Lake Erie", "D2:D841")*erie_area)/1000;
d3=xlsread("Raw","Lake Erie", "E2:E841")*60*60*24*30;
fo2=xlsread("Raw","Lake Erie", "F2:F841")*60*60*24*30;
fo3=xlsread("Raw","Lake Erie", "G2:G841")*60*60*24*30;
r4=(xlsread("Raw","Lake Ontario", "B2:B841")*ontar_area)/1000;
p4=(xlsread("Raw","Lake Ontario", "C2:C841")*ontar_area)/1000;
e4=(xlsread("Raw","Lake Ontario", "D2:D841")*ontar_area)/1000;
d3=xlsread("Raw","Lake Ontario", "E2:E841")*60*60*24*30;
fo4=xlsread("Raw","Lake Ontario", "G2:G841")*60*60*24*30;
%Creating inflow, outflow and dv/dt arrays to find the changing water balance.
%Water balances include real and controlled balances.
erie_inflow=r3+p3+fo2;
erie_non_liquid_outflow=e3;
%Water flow from Lake Erie to Ontario is isolated so it can be controlled
%in the dam system.
erie_to_ontar_flow=fo3+d3;
erie_total_outflow=erie_non_liquid_outflow+erie_to_ontar_flow;
erie_original_dvdt=erie_inflow-erie_total_outflow;
ontar_normal_inflow=p4+r4;
ontar_outflow=e4+fo4;
ontar_dvdt=ontar_normal_inflow+erie_to_ontar_flow-ontar_outflow;
%Calculating the original 1950 volume of Lakes Erie and Ontario by working backwards
%with the given data
%Lake Erie initial volume
backwards_erie_vol=[];
backwards_erie_vol(840)=erie_vol_2019-erie_original_dvdt(840);
for i = (length(erie_original_dvdt))-1:-1:1
    backwards_erie_vol(i)=[backwards_erie_vol(i+1)-erie_original_dvdt(i+1)];
end
initial_erie_vol=backwards_erie_vol(1);
%Lake Ontario initial volume
backwards_ontar_vol=[];
backwards_ontar_vol(840)=ontar_vol_2019-ontar_dvdt(840);
for i = (length(ontar_dvdt))-1:-1:1
    backwards_ontar_vol(i)=[backwards_ontar_vol(i+1)-ontar_dvdt(i+1)];
end
initial_ontar_vol=backwards_ontar_vol(1);
%The water balance model begins with the creation of the volume and balance arrays
erie_dvdt=[]';
ontar_vol=[];
erie_vol=[];
%Setting the initial values as this makes the outflows easier to control
%when compared to using cumtrapz.
erie_dvdt(1)=erie_inflow(1)-erie_total_outflow(1);
ontar_vol(1)=initial_ontar_vol+erie_to_ontar_flow(1)-ontar_outflow(1);
erie_vol(1)=initial_erie_vol+erie_dvdt(1);
%The model will simulate the system under different conditions thousands
%of times: percentage of allowed inflow into Lake Ontario from Erie and the 
%optimal average surface height of Lake Erie to stablise the volume of Lake Erie.
lowest_percentages=[];
lowest_heights=[];
lowest_means=[];
final_ontar_vol=[];
%A minimum percentage of 90% is chosen as too low will mean a huge amount
%of water flow is restricted which can be dangerous so 90% is considered as
%a safe minimum.
percentages=[0.90:0.01:1];
for x=percentages
%The ideal surface height of Lake Erie will be somewhere between the
%initial height in 1950 and 2019.
ideal_erie_height=[floor(erie_vol_2019/erie_area):0.01:ceil(initial_erie_vol/erie_area)];
for n=ideal_erie_height
%Thousands of simulations are running and each time temporary arrays are
%created to store the required values of the dv/dt means and lake volumes
%for example.
means_temp=[];
erie_height=[];
erie_height(1)=erie_vol(1)/erie_area;
for i = 2:840
    % If the previous months surface height of Lake Erie is less than the
    % optimal height then the flow out to Lake Ontario will be restricted
    % to prevent the volume from decreasing too much.
    if erie_height(i-1)<n;
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i)*x)-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);    
    %If the height is greater than or equal to then the flow is not restricted
    else
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i))-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
    end
    erie_height=[erie_height,(erie_vol(i)/erie_area)];
end
    %Here the array element id at which the lowest dv/dt for the last 25 years
    %(2004-2019) is found and used to find the optimal conditions.
    final_ontar_vol=[final_ontar_vol,ontar_vol(840)];
    means_temp=[means_temp,mean(erie_dvdt(540:840))];
    lowest_heights=[lowest_heights, n];
    lowest_percentages=[lowest_percentages, x];
    lowest_means=[lowest_means,min(abs(means_temp))];
end
end
%The optimal conditions will now need to be filtered and only those
%simulations that resulted in a volume that is greater than the
%initial volume under normal conditions to ensure it does not decrease.
accepted_ontar_final_vol=(initial_ontar_vol);
accepted_heights=[];
accepted_percentages=[];
accepted_lowest_dvdt=[];
accepted_volumes=[];
for i = 1:length(final_ontar_vol)
    if final_ontar_vol(i)>(accepted_ontar_final_vol);
        accepted_heights=[accepted_heights, lowest_heights(i)];
        accepted_percentages=[accepted_percentages, lowest_percentages(i)];
        accepted_lowest_dvdt=[accepted_lowest_dvdt, lowest_means(i)];
        accepted_volumes=[accepted_volumes, final_ontar_vol(i)];
    end
end
%After filtering, there may be multiple optimal conditions so the
%conditions that result in the lowest flow alteration are chosen which will
%be towards the end of the array hence the 'end' argument.
lowest_id=find(accepted_lowest_dvdt==min(accepted_lowest_dvdt));
if length(lowest_id)>1;
    lowest_id=[lowest_id(end)];
end

%Running the model using the optimum conditions this time
erie_dvdt=[];
ontar_vol=[];
erie_vol=[];
ontar_vol(1)=initial_ontar_vol+erie_to_ontar_flow(1)-ontar_outflow(1);
erie_vol(1)=initial_erie_vol+erie_inflow(1)-erie_total_outflow(1);
erie_height=[];
erie_height(1)=erie_vol(1)/erie_area;
x=accepted_percentages(lowest_id);
for i = 2:840
    ontar_height(i-1)=ontar_vol(i-1)/ontar_area;
    if erie_height(i-1)<accepted_heights(lowest_id);
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i)*x)-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i)*x);
    else
        erie_vol(i)=erie_vol(i-1)+erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
        ontar_vol(i)=ontar_vol(i-1)+ontar_normal_inflow(i)+(erie_to_ontar_flow(i))-ontar_outflow(i);
        erie_dvdt(i)=erie_inflow(i)-erie_non_liquid_outflow(i)-(erie_to_ontar_flow(i));
    end
     erie_height=[erie_height,(erie_vol(i)/erie_area)];
end

%The final optimal conditions are selected and displayed
disp("Below are the final optimum conditions and results of the simulation when they are used:")
disp("Lowest acceptable average surface height of Lake Erie: " + accepted_heights(lowest_id) + "m")
disp("Percentage of outflow that is allowed during restricted months: " + accepted_percentages(lowest_id)*100 + "%")
disp("Change in the volume of Lake Erie over past 25 years: "+ mean(erie_dvdt(540:840)) + "m3/month")
disp("Final volume of Lake Ontario under these conditions: " + accepted_volumes(lowest_id) + "m3")

%Plots which show lake volumes under the effect of the solution and
%optimal conditions:
figure()
plot(dates,erie_vol)
title("Volume of Lake Erie (controlled) 1950-2019 (m^3)")
xlabel("Time (Month)")
ylabel("Volume (m^3)")
grid on
grid minor
pbaspect([5 2 1])
figure()
plot(dates,ontar_vol)
title("Volume of Lake Ontario (controlled) 1950-2019 (m^3)")
xlabel("Time (Month)")
ylabel("Volume (m^3)")
grid on
grid minor
pbaspect([5 2 1])

%Below the cumtrapz function is used to show what the volumes of the lakes
%really looked like during the period, 1950-2019 to allow for a comparison.
%Lake Erie Natural Volume:
erie_natural_inflow=r3+p3+fo2;
erie_natural_outflow=e3+fo3+d3;
erie_natural_dvdt=erie_natural_inflow-erie_natural_outflow;
erie_natural_vol=initial_erie_vol+datenum(cumtrapz(1,erie_natural_dvdt));
figure()
plot(dates,erie_natural_vol)
grid on
grid minor
title("Volume of Lake Erie (natural) 1950-2019 (m^3)")
xlabel("Time (month)")
ylabel("Volume (m^3)")
pbaspect([5 2 1])

%Lake Ontario Natural Volume:
ontar_natural_inflow=r4+p4+fo3+d3;
ontar_natural_outflow=e4+fo4;
ontar_natural_dvdt=ontar_natural_inflow-ontar_natural_outflow;
ontar_natural_vol=initial_ontar_vol+datenum(cumtrapz(1,ontar_natural_dvdt));
figure()
plot(dates,ontar_natural_vol)
grid on
grid minor
title("Volume of Lake Ontario (natural) 1950-2019 (m^3)")
xlabel("Time (month)")
ylabel("Volume (m^3)")
pbaspect([5 2 1])
##### SOURCE END #####
--></body></html>
